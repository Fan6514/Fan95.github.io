{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/04/08/hello-world/"},{"title":"计算机网络｜物理层","text":"物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体传输媒体。主要任务：确定与传输媒体的接口有关的一些特性，如机械特性、电气特性、功能特性和过程特性。 1. 物理层的基本概念物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体传输媒体。主要任务：确定与传输媒体的接口有关的一些特性，如机械特性、电气特性、功能特性和过程特性。 1.1 通信方式信道(channel)是用来表示像某一个方向传送信息的媒体，根据信息在传输线上的传送方向，分为以下三种通信方式： 单工通信：单向传输，只能有一个方向的传输而没有反方向的交互。 半双工通信：双向交替传输，通信的双方都可以发送消息，但不能双方同时发送（接收）。 全双工通信：双向同时传输，通信的双方可以同时发送和接收消息。 1.2 调制(modulation)基带信号（即基本频带信号）是来自信源的信号。为了解决基带信号传输低频分量或直流分量，必须对基带信号进行调制。 两类调制： 编码(coding)：基带调制，仅对基带信号的波形进行变换，使它能与信道特性相适应，变换后的信号仍然是基带信号。 带通调制：使用载波(carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号。经过载波调制的信号成为带通信号（即仅在一段频率范围内能够通过信道），使用载波进行的调制称为带通调制。 基本的带通调制方法 调幅(AM)：载波的振幅随基带数字信号而变化。例如0和1分别对应于无载波或有载波输出。 调频(FM)：载波的频率随基带数字信号而变化。例如0和1分别对应于频率$f_1$和$f_2$。 调相(PM)：载波的初始相位随基带数字信号而变化。例如0和1分别对应于相位0度和180度。 1.3 信噪比信噪比是信号平均功率和噪声平均功率之比，常记为S/NS/N，单位是分贝(dB)。$$信噪比(dB)=10log_{10}(S/N)(dB)$$香农公式：信道的极限传输速率为$$C=Wlog_2(1+S/N)(bit/s)$$其中$W$为信道的带宽(Hz)，信道的带宽或信道中的信噪比越大，信道的极限传输速率越高。 2. 信道复用技术复用技术是在发送端使用复用器，使用一个共享信道进行通信，在接收端使用分用器，把合起来传输的信息分别传送到相应的终点。 2.1 频分复用(FDM)频分复用FDM(Frequency Division Multiplexing)的所有主机在相同的时间占用不同的频率带宽资源。 2.2 时分复用(TDM)时分复用TDM(Time Division Multiplexing)的所有主机在不同的时间占用相同的频率带宽资源。 使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。 2.3 统计时分复用(STDM)统计时分复用(Statistic TDM)是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。 2.4 波分复用WDM波分复用WDM(Wavelength Division Multiplexing)就是光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。 2.5 码分复用CDM码分多址CMDA(Code Division Mutiplexing Access)为每个用户分配 m bit 的码片(chip)，并且所有的码片正交，对于任意两个码片 /vecS 和 /vecT 有 $$\\frac{1}{m}ST=0$$为了讨论方便，取 m=8，设码片 \\vecS 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到$$\\frac{1}{m}SS=1$$$$\\frac{1}{m}SS’=-1$$其中$S’$为 /vecS 的反码。 利用上面的式子我们知道，当接收端使用码片 /vecT 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1的是用户发送的比特 0。 码分复用需要发送的数据量为原先的 m 倍。","link":"/2020/04/18/%E7%89%A9%E7%90%86%E5%B1%82/"},{"title":"计算机网络｜网络结构体系","text":"计算机网络（简称网络）是由若干结点（node）和连接这些结点的链路（link）组成。网络中的结点可以是计算机、集线器、交换机或路由器等。而互联网是将多种不同的网络通过路由器连接起来，即互联网是网络的网络。互联网服务提供商(ISP, Internet Service Provider)可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点(IXP, Internet eXchange Point)允许两个 ISP 直接相连而不用经过第三个 ISP 来分组转发。 1.1 互联网的组成网络边缘的端系统之间的通信方式有两类：客户-服务器方式(C/S方式)和对等方式(P2P方式) 1. 客户-服务器方式客户(client)和服务器(server)都是指通信中所涉及的两个应用进程，客户是服务请求方，服务器是服务提供方。 2. 对等连接方式对等连接(peer-to-peer, P2P)是指两台主机在通信中不区分服务请求方和服务提供方 3. 互联网的核心部分路由器(router)是一种专用计算机，是实现分组交换(packet switching)的关键构件，其任务是转发收到的分组 电路交换 交换(switching)就是按照某种方式动态地分配传输线路的资源。电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。过程：建立连接（占用通信资源） -&gt; 通话（一只占用通信资源） -&gt; 释放连接（归还通信资源）特点：在通话的全部时间内，通话的两个用户始终占用端到端的通信资源。 分组交换 分组交换采用存储转发技术，发送的整块数据称为报文(message)，先把较长的报文分为等长的数据段，在每个数据段的前面加上控制信息组成首部(header)，构成一个分组(packet)，分组又称为包，分组首部又称为包头。过程：路由器收到一个分组后，先暂时存储一下，检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去，把分组交给下一个路由器。注意此时的路由器存储的是一个个短分组，而不是整个报文，且短分组存储在路由器的存储器（即内存）而不是磁盘中。 时延 分组在各路由器中存储转发时需要排队造成时延(delay)，分组交换带来的另一个问题时各分组必须携带的控制信息也造成一定开销(overhead)。 总时延 = 排队时延 + 处理时延 + 发送时延 + 传播时延 发送时延(transmission delay)或传输时延是主机或路由器发送数据帧所需的时间。$$发送时延=\\frac{数据帧长度(bit)}{发送速率(bit/s)}$$传播时延是电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。$$传播=\\frac{信道长度(m)}{电磁波在信道上的传播速率(m/s)}$$排队时延是分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。处理时延是主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。 1.2 计算机网络体系结构（重点）计算机网络体系结构采用了分层的思想。那么，既然计算机网络体系结构的设计采用的是分层思想，那么它就必须得解决以下几个问题： 网络体系结构应该具有哪些层次，每个层次又负责哪些功能呢？ 分层与功能 各个层次之间的关系是怎样的，它们又是如何进行交互的呢？服务与接口 要想确保通信的双方能够达成高度默契，它们又需要遵循哪些规则呢？ 协议 计算机网络体系结构必须包括三个内容，即分层结构与每层的功能、服务与层间接口和协议。所以，计算机网络体系结构的定义为：在计算机网络中，各层、各层间的接口及协议的集合被称为计算机网络体系结构。 1.五层协议体系结构目前，由国际化标准组织ISO制定的网络体系结构国际标准是 OSI七层模型，但实际中应用最广泛的是 TCP/IP体系结构。换句话说，OSI七层模型只是理论上的、官方制定的国际标准，而TCP/IP体系结构才是事实上的国际标准。 应用层(application layer)：通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等等。我们把应用层交互的数据单元称为报文。 传输层(transport layer)：负责向两台主机进程之间的通信提供通用的数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议TCP(Transmission Control Protocal)，提供面向连接、可靠的数据传输服务，数据单位为报文段(segment)；用户数据报协议UDP(User Datagram Protocal)，提供无连接、尽最大努力的数据传输服务（不保证数据传输的可靠性），数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层：为分组交换网上的不同主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组或包进行传送。 数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧(frame)。 物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 2. OSI体系结构其中表示层和会话层用途如下：表示层：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。会话层：建立及管理会话。 五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。 3. TCP/IP体系结构它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。 4. 数据在各层之间的传递过程在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。","link":"/2020/04/08/%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E4%BD%93%E7%B3%BB/"},{"title":"操作系统｜操作系统概述","text":"计算机系统是由系统软件和硬件组成的，它们共同工作来运行应用程序。 1. 操作系统内核特征并发并发是指宏观上在一段时间内能同时运行多个程序，需要 OS 管理和调度；而并行则指同一时刻能运行多个指令。并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。 操作系统通过引入进程和线程，使得程序能够并发运行。 共享共享是指系统中的资源可以被多个并发进程共同使用。在宏观上实现“同时访问”资源，在微观上实现互斥访问。 有两种共享方式：互斥共享和同时共享。互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。 虚拟虚拟技术把一个物理实体转换为多个逻辑实体。主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。 多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。 虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。 异步异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。只要运行环境相同，OS 需要保证程序运行的结果也相同。 2. 操作系统基本功能内存管理内存分配、地址映射、内存保护与共享、虚拟内存等。 对任何一台计算机而言，其内存以及其它资源都是有限的。为了让有限的物理内存满足应用程序对内存的大需求量，Linux 采用了称为“虚拟内存”的内存管理方式。Linux 将内存划分为容易处理的“内存页”（对于大部分体系结构来说都是 4KB）。Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。 不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。 为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为交换，因为页面会被从内存交换到硬盘上。内存管理的源代码可以在 ./linux/mm 中找到。 进程管理进程控制、进程同步、进程通信、死锁处理、处理机调度等。 进程实际是某特定应用程序的一个运行实体。在 Linux 系统中，能够同时运行多个进程，Linux 通过在短的时间间隔内轮流运行这些进程而实现“多任务”。这一短的时间间隔称为“时间片”，让进程轮流运行的方法称为“进程调度” ，完成调度的程序称为调度程序。 进程调度控制进程对 CPU 的访问。当需要选择下一个进程运行时，由调度程序选择最值得运行的进程。可运行进程实际上是仅等待CPU资源的进程，如果某个进程在等待其它资源，则该进程是不可运行进程。Linux 使用了比较简单的基于优先级的进程调度算法选择新的进程。 通过多任务机制，每个进程可认为只有自己独占计算机，从而简化程序的编写。每个进程有自己单独的地址空间，并且只能由这一进程访问，这样，操作系统避免了进程之间的互相干扰以及“坏”程序对系统可能造成的危害。 为了完成某特定任务，有时需要综合两个程序的功能，例如一个程序输出文本，而另一个程序对文本进行排序。为此，操作系统还提供进程间的通讯机制来帮助完成这样的任务。Linux 中常见的进程间通讯机制有信号、管道、共享内存、信号量和套接字等。 内核通过 SCI 提供了一个应用程序编程接口（API）来创建一个新进程（fork、exec 或 Portable Operating System Interface [POSⅨ] 函数），停止进程（kill、exit），并在它们之间进行通信和同步（signal 或者 POSⅨ 机制）。 文件管理文件存储空间的管理、目录管理、文件读写管理和保护等。 Linux 操作系统将独立的文件系统组合成了一个层次化的树形结构，并且由一个单独的实体代表这一文件系统。Linux 将新的文件系统通过一个称为“挂装”或“挂上”的操作将其挂装到某个目录上，从而让不同的文件系统结合成为一个整体。 Linux 操作系统的一个重要特点是它支持许多不同类型的文件系统。Linux 中最普遍使用的文件系统是 Ext2，它也是 Linux 土生土长的文件系统。但 Linux 也能够支持 FAT、VFAT、FAT32、MINIX 等不同类型的文件系统，从而可以方便地和其它操作系统交换数据。由于 Linux 支持许多不同的文件系统，并且将它们组织成了一个统一的虚拟文件系统。 虚拟文件系统(VirtualFileSystem, VFS)：隐藏了各种硬件的具体细节，把文件系统操作和不同文件系统的具体实现细节分离了开来，为所有的设备提供了统一的接口，VFS提供了多达数十种不同的文件系统。虚拟文件系统可以分为逻辑文件系统和设备驱动程序。逻辑文件系统指Linux所支持的文件系统，如ext2,fat等，设备驱动程序指为每一种硬件控制器所编写的设备驱动程序模块。 设备管理完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。主要包括缓冲管理、设备分配、设备处理、虛拟设备等。 设备驱动程序运行在高特权级的处理器环境中，从而可以直接对硬件进行操作，但正因为如此，任何一个设备驱动程序的错误都可能导致操作系统的崩溃。设备驱动程序实际控制操作系统和硬件设备之间的交互。 设备驱动程序提供一组操作系统可理解的抽象接口完成和操作系统之间的交互，而与硬件相关的具体操作细节由设备驱动程序完成。一般而言，设备驱动程序和设备的控制芯片有关，例如，如果计算机硬盘是 SCSI 硬盘，则需要使用 SCSI 驱动程序，而不是 IDE 驱动程序。 网络接口(NET)提供了对各种网络标准的存取和各种网络硬件的支持。网络接口可分为网络协议和网络驱动程序。网络协议部分负责实现每一种可能的网络传输协议。众所周知，TCP/IP 协议是 Internet 的标准协议，同时也是事实上的工业标准。 Linux 的网络实现支持 BSD 套接字，支持全部的 TCP/IP 协议。Linux内核的网络部分由 BSD 套接字、网络协议层和网络设备驱动程序组成。网络设备驱动程序负责与硬件设备通讯，每一种可能的硬件设备都有相应的设备驱动程序。 3. Unix/Linux的体系架构 Linux操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。内核从本质上看是一种软件——控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。 系统调用(system call)系统调用是应用程序主动向操作系统发出的请求，是操作系统的最小功能单位，这些系统调用根据不同的应用场景可以进行扩展和裁剪，现在各种版本的Unix实现都提供了不同数量的系统调用，如 Linux 的不同版本提供了 240-260 个系统调用。我们可以把系统调用看成是一种不能再化简的操作，有人把它比作一个汉字的一个“笔画”，而一个“汉字”就代表一个上层应用，我觉得这个比喻非常贴切。因此，有时候如果要实现一个完整的汉字（给某个变量分配内存空间），就必须调用很多的系统调用。如果从实现者的角度来看，良好的程序设计方法是：重视上层的业务逻辑操作，而尽可能避免底层复杂的实现细节。 库函数库函数正是为了将开发者从复杂的细节中解脱出来而提出的一种有效方法。它实现对系统调用的封装，将简单的业务逻辑接口呈现给用户，方便用户调用，从这个角度上看，库函数就像是组成汉字的“偏旁”。这样的一种组成方式极大增强了程序设计的灵活性，对于简单的操作，我们可以直接调用系统调用来访问资源，如“人”，对于复杂操作，我们借助于库函数来实现。显然，这样的库函数依据不同的标准也可以有不同的实现版本，如ISO C 标准库，POSIX标准库等。 ShellShell是一个特殊的应用程序，俗称命令行，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行，是一个命令解释器。它下通系统调用，上通各种应用，通常充当着一种“胶水”的角色，来连接各个小功能程序，让不同程序能够以一个清晰的接口协同工作，从而增强各个程序的功能。同时，Shell是可编程的，它可以执行符合Shell语法的文本，这样的文本称为Shell脚本，通常短短的几行Shell脚本就可以实现一个非常大的功能，原因就是这些Shell语句通常都对系统调用做了一层封装。为了方便用户和系统交互，一般，一个Shell对应一个终端，终端是一个硬件设备，呈现给用户的是一个图形化窗口。我们可以通过这个窗口输入或者输出文本。这个文本直接传递给shell进行分析解释，然后执行。 用户态的应用程序可以通过三种方式来访问内核态的资源： 系统调用 库函数 Shell脚本 用户态和内核态内核态：CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡，CPU 也可以将自己从一个程序切换到另一个程序用户态：只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取 由于需要限制不同的程序之间的访问能力, 防止它们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级——用户态和内核态 所有用户程序都是运行在用户态的, 但是有时候程序确实需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入等， 而唯一可以做这些事情的就是操作系统, 所以此时程序就需要向操作系统请求以程序的名义来执行这些操作。 4. 中断、异常和陷入中断(hardward interrupt)中断来自硬件设备的处理请求。响应方式：异步处理机制：持续，对应用程序是透明的 异常(exception)异常是非法指令或者其他原因导致当前指令执行失败。由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。响应方式：同步处理机制：杀死或重新执行应用程序指令 陷入在用户程序中使用系统调用。响应方式：同步或异步处理机制：等待和持续","link":"/2020/04/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"categories":[]}